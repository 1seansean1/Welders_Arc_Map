# Lessons Learned: Coordinate Drift Debugging
## Satellite Visualization System - WA_map

**Date**: 2025-11-24
**Issue**: Satellites and sensors appeared to "wander away" from their geographic positions during pan/zoom
**Status**: ✅ RESOLVED

---

## Problem Statement

### Initial Symptoms
- Objects rendered in seemingly correct positions initially
- During ANY pan or zoom operation, objects drifted away from their geographic locations
- Objects maintained correct positions RELATIVE TO EACH OTHER
- All objects moved "together-but-separately" from the base map
- **Critical symptom**: "They appear to render correctly on map at max zoom out but when I pan they move faster than the map in pan-direction. This is amplified when I zoom in farther."

### User Insight
The user provided excellent guidance:
> "carefully consider coordinate frame proper use, ECI, ECEF, ITRF, GCRF, topocentric, etc. carefully consider coordinate rotations as needed this is often an issue"

This was prophetic - it WAS a coordinate system issue, but not in the way we initially thought.

---

## Investigation Approach

### What We Did RIGHT
1. **Used existing logs** - No need to add new logging, analyzed existing UILogger output
2. **Systematic elimination** - Fixed issues one at a time, tested each
3. **Listened to user feedback** - User's observation "too consistent for it to be a firing issue" redirected investigation
4. **Read documentation** - Feature_list_2D_Map.txt contained the key to the final solution
5. **Followed symptoms** - The "amplified at higher zoom" clue was critical

### What We Struggled With
- **Assumed coordinate system was the problem** - Spent time on LNGLAT declaration when that wasn't the issue
- **Focused on performance first** - Throttling was a red herring
- **Device pixel confusion** - useDevicePixels was a real issue but not THE issue

---

## Failed Fixes (and Why They Failed)

### Fix #1: Added coordinateSystem: COORDINATE_SYSTEM.LNGLAT
**What we thought**: Deck.gl wasn't transforming WGS84 coordinates to Web Mercator properly
**Why it failed**: Deck.gl defaults to LNGLAT anyway for MapView - this was already happening
**User feedback**: "still busted"
**Lesson**: Explicit declarations don't fix implicit behavior if it was already working

### Fix #2: Added views: new MapView({repeat: true})
**What we thought**: World wrapping wasn't enabled, causing clipping
**Why it partially worked**: This DID fix FOV clipping at world edges (legitimate issue)
**Why drift persisted**: World wrapping and coordinate alignment are separate concerns
**Lesson**: One fix can solve multiple problems - this fixed wrapping but not drift

### Fix #3: Added wrapLongitude: true to all layers
**What we thought**: Layers needed explicit world wrapping
**Why it partially worked**: Improved rendering on wrapped world copies
**Why drift persisted**: Still didn't address the zoom scale mismatch
**Lesson**: Visual improvements don't always fix underlying coordinate math

### Fix #4: Canvas resizing + auto-correction
**What we thought**: Canvas size mismatch (297×158px) was causing coordinate transforms to fail
**Why it partially worked**: Canvas sizing WAS broken, this fixed maximize/restore
**Why drift persisted**: Canvas size affects click events and rendering, not coordinate scales
**Lesson**: Fix real bugs even if they're not THE bug - logs revealed a legitimate issue

### Fix #5: Throttled sync to 60 FPS
**What we thought**: Sync function firing too often was causing coordinate errors
**User's critical insight**: "i really dont see how sync firing too often creates this very smooth, but very inaccurate result. it is too consistent for it to be a firing issue."
**Why it failed**: The user was 100% correct - smooth drift ≠ timing issue
**Lesson**: LISTEN when user provides technical reasoning. This saved us hours of chasing timing bugs.

### Fix #6: Changed useDevicePixels from 2 to false
**What we thought**: Device pixel ratio mismatch (2x on retina) was causing 2x scale error
**Why it partially worked**: This WAS causing a scale issue (CSS pixels vs device pixels)
**User feedback**: "getting closer but not quite right"
**Why drift persisted**: 2x scale error is linear, but drift was EXPONENTIAL at higher zooms
**Lesson**: If a fix improves things but doesn't solve it, you're on the right track but missing something

---

## The Breakthrough

### The Critical Clue
User's final description:
> "they appear to render correctly on map at max zoom out but when I pan they move faster than the map in pan-direction. This is amplified I think when I zoom in farther."

### Why This Was The Key
- "Correct at max zoom out" → Base case (zoom 1-2) was close enough to hide the error
- "Move faster during pan" → Scale mismatch, not position offset
- "Amplified at higher zoom" → EXPONENTIAL error, not linear

### The Math
```
Leaflet uses: scale = 2^zoom
Deck.gl MapView uses: scale = 2^(zoom - 1)

At zoom 1:  Leaflet = 2¹ = 2,    Deck.gl = 2⁰ = 1    (2x difference, barely noticeable)
At zoom 5:  Leaflet = 2⁵ = 32,   Deck.gl = 2⁴ = 16   (2x difference, very visible)
At zoom 10: Leaflet = 2¹⁰ = 1024, Deck.gl = 2⁹ = 512 (2x difference, extreme)
```

The 2x scale difference is CONSTANT, but because zoom is exponential, the pixel error amplifies exponentially.

### The Documentation
Feature_list_2D_Map.txt line 176:
> "Zoom Offset - Deck.gl zoom is Leaflet zoom - 1 (compatibility)"

This was documented all along! The documentation told us exactly what to do.

---

## The Final Solution

### The Fix (app.js:1872)
```javascript
// WRONG (what we had):
zoom: zoom,

// CORRECT:
zoom: zoom - 1,  // CRITICAL: Deck.gl MapView needs zoom - 1 for Leaflet compatibility
```

### Why It Works
- Leaflet reports zoom as integer (e.g., zoom = 5)
- Deck.gl MapView expects zoom relative to its own scale system
- Deck.gl's zoom scale is offset by -1 from Leaflet's for historical/compatibility reasons
- By passing `zoom - 1`, both systems now use the same scale: 2^(zoom-1)

### The Result
✅ Objects render correctly at ALL zoom levels
✅ Objects stay locked to geographic positions during pan
✅ No drift at any zoom level
✅ Smooth, accurate rendering

---

## Key Lessons Learned

### Technical Lessons

1. **Read The Documentation First**
   - The fix was documented in Feature_list_2D_Map.txt
   - Could have saved hours by consulting docs before debugging

2. **Exponential Systems Are Tricky**
   - Zoom systems use powers of 2 (exponential growth)
   - Small constant errors (like offset by 1) cause exponential pixel errors
   - Always check for scale/offset issues in exponential coordinate systems

3. **Coordinate System != Coordinate Scale**
   - LNGLAT vs METER_OFFSET is about coordinate SYSTEM
   - Zoom offset is about coordinate SCALE
   - These are separate concerns

4. **Device Pixels vs CSS Pixels Matter**
   - Leaflet uses CSS pixels (viewport coordinates)
   - Deck.gl can use device pixels (physical screen pixels)
   - Mismatch causes 2x scale error on retina displays
   - useDevicePixels: false ensures 1:1 mapping

5. **Canvas Size Affects Transforms**
   - Container and canvas dimensions must match exactly
   - Mismatch causes click coordinates to map incorrectly
   - Auto-correction in sync function prevents drift

6. **World Wrapping Is Separate From Coordinate Math**
   - wrapLongitude: true makes layers render on wrapped copies
   - This fixes visual clipping but doesn't affect coordinate transforms
   - Both are needed for correct behavior

### Debugging Lessons

1. **Listen To User Technical Observations**
   - "too consistent for it to be a firing issue" redirected investigation
   - User's zoom level observation was the breakthrough
   - Domain experts often see patterns you don't

2. **Symptom Precision Matters**
   - "Correct at low zoom, drifts at high zoom" = exponential error
   - "Always wrong by same amount" = offset error
   - "Wrong by scaling factor" = scale error
   - The PATTERN of error reveals the ROOT CAUSE

3. **Fix Real Bugs Even If They're Not THE Bug**
   - Canvas sizing was broken (found via logs)
   - World wrapping was broken (found via screenshots)
   - Both needed fixing even though neither was the main issue
   - Each fix improved the system

4. **Performance ≠ Correctness**
   - Throttling doesn't fix coordinate math
   - But it's still good for performance
   - Keep performance fixes separate from correctness fixes

5. **Use Existing Logs Wisely**
   - UILogger output revealed canvas size mismatch
   - No need to add new logging
   - Analyze what you already have first

### Process Lessons

1. **Systematic Elimination Works**
   - Fix one thing at a time
   - Test after each fix
   - User feedback guides next step

2. **Documentation Is Your Friend**
   - Feature_list_2D_Map.txt had the answer
   - Always check docs before deep debugging
   - Document solutions for future reference (this file!)

3. **Integration Issues Are Multi-Layered**
   - Leaflet + Deck.gl integration has many moving parts
   - Coordinate system, scale, canvas size, device pixels, world wrapping
   - Each layer can have issues
   - Fix them in order from most obvious to most subtle

---

## Technical Deep Dive: Why Zoom - 1?

### Leaflet's Zoom System
- Zoom 0 = entire world fits in 256×256 pixels
- Zoom 1 = entire world fits in 512×512 pixels (2× scale)
- Zoom n = entire world fits in 256 × 2^n pixels
- Scale = 2^zoom

### Deck.gl MapView Zoom System
- Designed to match Mapbox GL JS zoom system
- Zoom 0 = same as Leaflet zoom 1 (historical reasons)
- To match Leaflet's scale, Deck.gl needs zoom - 1

### The Coordinate Math
```
Leaflet center: (lng, lat) at zoom z
Leaflet scale: 2^z

To convert Leaflet zoom to Deck.gl zoom:
deckZoom = leafletZoom - 1

To convert screen pixels to world coordinates:
worldX = (screenX - centerX) / scale
worldY = (screenY - centerY) / scale

If scales don't match, worldX and worldY are wrong!
```

### Why It Amplifies At Higher Zoom
At zoom 1, error = 2¹ - 2⁰ = 2 - 1 = 1 pixel/degree
At zoom 5, error = 2⁵ - 2⁴ = 32 - 16 = 16 pixels/degree
At zoom 10, error = 2¹⁰ - 2⁹ = 1024 - 512 = 512 pixels/degree

The error DOUBLES with each zoom level because scale is exponential!

---

## Prevention For Future

### Before Integration
1. Read both libraries' documentation on coordinate systems
2. Check if zoom/scale systems match
3. Test at multiple zoom levels (especially high zoom)
4. Document any required offsets in Feature_list

### During Development
1. Test pan/zoom behavior at zoom 1, 5, 10, 15
2. Check if error increases with zoom (exponential) or stays constant (linear)
3. Verify objects stay locked to known geographic coordinates
4. Use logs to check coordinate transforms

### Code Standards
1. Always comment coordinate system transformations
2. Document zoom offsets with "CRITICAL" comments
3. Include math explanation for non-obvious transforms
4. Reference documentation in comments

---

## Summary

**Root Cause**: Zoom scale mismatch between Leaflet (2^zoom) and Deck.gl MapView (2^(zoom-1))

**Failed Fixes**: Coordinate system declaration, throttling, device pixels (though device pixels WAS a real issue)

**Breakthrough**: User's observation that error "amplified at higher zoom" = exponential error

**Solution**: Pass `zoom - 1` to Deck.gl instead of `zoom`

**Time To Fix**: Multiple iterations over extended debugging session

**Key Insight**: Read the docs! Feature_list_2D_Map.txt documented this requirement.

**Files Modified**:
- app.js:1872 (zoom offset in syncDeckWithLeaflet)
- app.js:1757 (useDevicePixels: false)
- app.js:1738 (MapView with repeat: true)
- app.js:1183, 1217, 1239 (wrapLongitude: true on layers)

**Related Issues Fixed**:
- Canvas size mismatch (auto-correction)
- World wrapping (MapView + wrapLongitude)
- Device pixel ratio (useDevicePixels: false)
- Performance (60 FPS throttling)

---

## Final Thoughts

This was a textbook example of **integration debugging**. The issue wasn't in Leaflet OR Deck.gl individually - both work perfectly. The issue was in the **handoff between them**.

The user's technical intuition was excellent:
- Suggested coordinate system issues early
- Recognized timing wasn't the problem
- Provided precise symptom descriptions
- Noticed the zoom level correlation

The debugging process was systematic but could have been faster by:
1. Reading Feature_list_2D_Map.txt FIRST
2. Testing at extreme zoom levels earlier
3. Calculating expected vs actual scales mathematically

**Most Important Lesson**: When integrating two coordinate systems, verify scales match at multiple zoom levels. Exponential errors hide at low zoom and explode at high zoom.

---

**Status**: ✅ RESOLVED
**Confidence**: 100% - Objects now locked to geographic positions at all zoom levels
**Next Steps**: Monitor for any edge cases, document zoom offset requirement prominently
