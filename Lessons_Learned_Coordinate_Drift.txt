# Lessons Learned: Coordinate Drift Debugging
## Satellite Visualization System - WA_map

**Date**: 2025-11-24
**Issue**: Satellites and sensors appeared to "wander away" from their geographic positions during pan/zoom
**Status**: ✅ RESOLVED

---

## Problem Statement

### Initial Symptoms
- Objects rendered in seemingly correct positions initially
- During ANY pan or zoom operation, objects drifted away from their geographic locations
- Objects maintained correct positions RELATIVE TO EACH OTHER
- All objects moved "together-but-separately" from the base map
- **Critical symptom**: "They appear to render correctly on map at max zoom out but when I pan they move faster than the map in pan-direction. This is amplified when I zoom in farther."

### User Insight
The user provided excellent guidance:
> "carefully consider coordinate frame proper use, ECI, ECEF, ITRF, GCRF, topocentric, etc. carefully consider coordinate rotations as needed this is often an issue"

This was prophetic - it WAS a coordinate system issue, but not in the way we initially thought.

---

## Investigation Approach

### What We Did RIGHT
1. **Used existing logs** - No need to add new logging, analyzed existing UILogger output
2. **Systematic elimination** - Fixed issues one at a time, tested each
3. **Listened to user feedback** - User's observation "too consistent for it to be a firing issue" redirected investigation
4. **Read documentation** - Feature_list_2D_Map.txt contained the key to the final solution
5. **Followed symptoms** - The "amplified at higher zoom" clue was critical

### What We Struggled With
- **Assumed coordinate system was the problem** - Spent time on LNGLAT declaration when that wasn't the issue
- **Focused on performance first** - Throttling was a red herring
- **Device pixel confusion** - useDevicePixels was a real issue but not THE issue

---

## Failed Fixes (and Why They Failed)

### Fix #1: Added coordinateSystem: COORDINATE_SYSTEM.LNGLAT
**What we thought**: Deck.gl wasn't transforming WGS84 coordinates to Web Mercator properly
**Why it failed**: Deck.gl defaults to LNGLAT anyway for MapView - this was already happening
**User feedback**: "still busted"
**Lesson**: Explicit declarations don't fix implicit behavior if it was already working

### Fix #2: Added views: new MapView({repeat: true})
**What we thought**: World wrapping wasn't enabled, causing clipping
**Why it partially worked**: This DID fix FOV clipping at world edges (legitimate issue)
**Why drift persisted**: World wrapping and coordinate alignment are separate concerns
**Lesson**: One fix can solve multiple problems - this fixed wrapping but not drift

### Fix #3: Added wrapLongitude: true to all layers
**What we thought**: Layers needed explicit world wrapping
**Why it partially worked**: Improved rendering on wrapped world copies
**Why drift persisted**: Still didn't address the zoom scale mismatch
**Lesson**: Visual improvements don't always fix underlying coordinate math

### Fix #4: Canvas resizing + auto-correction
**What we thought**: Canvas size mismatch (297×158px) was causing coordinate transforms to fail
**Why it partially worked**: Canvas sizing WAS broken, this fixed maximize/restore
**Why drift persisted**: Canvas size affects click events and rendering, not coordinate scales
**Lesson**: Fix real bugs even if they're not THE bug - logs revealed a legitimate issue

### Fix #5: Throttled sync to 60 FPS
**What we thought**: Sync function firing too often was causing coordinate errors
**User's critical insight**: "i really dont see how sync firing too often creates this very smooth, but very inaccurate result. it is too consistent for it to be a firing issue."
**Why it failed**: The user was 100% correct - smooth drift ≠ timing issue
**Lesson**: LISTEN when user provides technical reasoning. This saved us hours of chasing timing bugs.

### Fix #6: Changed useDevicePixels from 2 to false
**What we thought**: Device pixel ratio mismatch (2x on retina) was causing 2x scale error
**Why it partially worked**: This WAS causing a scale issue (CSS pixels vs device pixels)
**User feedback**: "getting closer but not quite right"
**Why drift persisted**: 2x scale error is linear, but drift was EXPONENTIAL at higher zooms
**Lesson**: If a fix improves things but doesn't solve it, you're on the right track but missing something

---

## The Breakthrough

### The Critical Clue
User's final description:
> "they appear to render correctly on map at max zoom out but when I pan they move faster than the map in pan-direction. This is amplified I think when I zoom in farther."

### Why This Was The Key
- "Correct at max zoom out" → Base case (zoom 1-2) was close enough to hide the error
- "Move faster during pan" → Scale mismatch, not position offset
- "Amplified at higher zoom" → EXPONENTIAL error, not linear

### The Math
```
Leaflet uses: scale = 2^zoom
Deck.gl MapView uses: scale = 2^(zoom - 1)

At zoom 1:  Leaflet = 2¹ = 2,    Deck.gl = 2⁰ = 1    (2x difference, barely noticeable)
At zoom 5:  Leaflet = 2⁵ = 32,   Deck.gl = 2⁴ = 16   (2x difference, very visible)
At zoom 10: Leaflet = 2¹⁰ = 1024, Deck.gl = 2⁹ = 512 (2x difference, extreme)
```

The 2x scale difference is CONSTANT, but because zoom is exponential, the pixel error amplifies exponentially.

### The Documentation
Feature_list_2D_Map.txt line 176:
> "Zoom Offset - Deck.gl zoom is Leaflet zoom - 1 (compatibility)"

This was documented all along! The documentation told us exactly what to do.

---

## The Final Solution

### The Fix (app.js:1872)
```javascript
// WRONG (what we had):
zoom: zoom,

// CORRECT:
zoom: zoom - 1,  // CRITICAL: Deck.gl MapView needs zoom - 1 for Leaflet compatibility
```

### Why It Works
- Leaflet reports zoom as integer (e.g., zoom = 5)
- Deck.gl MapView expects zoom relative to its own scale system
- Deck.gl's zoom scale is offset by -1 from Leaflet's for historical/compatibility reasons
- By passing `zoom - 1`, both systems now use the same scale: 2^(zoom-1)

### The Result
✅ Objects render correctly at ALL zoom levels
✅ Objects stay locked to geographic positions during pan
✅ No drift at any zoom level
✅ Smooth, accurate rendering

---

## Key Lessons Learned

### Technical Lessons

1. **Read The Documentation First**
   - The fix was documented in Feature_list_2D_Map.txt
   - Could have saved hours by consulting docs before debugging

2. **Exponential Systems Are Tricky**
   - Zoom systems use powers of 2 (exponential growth)
   - Small constant errors (like offset by 1) cause exponential pixel errors
   - Always check for scale/offset issues in exponential coordinate systems

3. **Coordinate System != Coordinate Scale**
   - LNGLAT vs METER_OFFSET is about coordinate SYSTEM
   - Zoom offset is about coordinate SCALE
   - These are separate concerns

4. **Device Pixels vs CSS Pixels Matter**
   - Leaflet uses CSS pixels (viewport coordinates)
   - Deck.gl can use device pixels (physical screen pixels)
   - Mismatch causes 2x scale error on retina displays
   - useDevicePixels: false ensures 1:1 mapping

5. **Canvas Size Affects Transforms**
   - Container and canvas dimensions must match exactly
   - Mismatch causes click coordinates to map incorrectly
   - Auto-correction in sync function prevents drift

6. **World Wrapping Is Separate From Coordinate Math**
   - wrapLongitude: true makes layers render on wrapped copies
   - This fixes visual clipping but doesn't affect coordinate transforms
   - Both are needed for correct behavior

### Debugging Lessons

1. **Listen To User Technical Observations**
   - "too consistent for it to be a firing issue" redirected investigation
   - User's zoom level observation was the breakthrough
   - Domain experts often see patterns you don't

2. **Symptom Precision Matters**
   - "Correct at low zoom, drifts at high zoom" = exponential error
   - "Always wrong by same amount" = offset error
   - "Wrong by scaling factor" = scale error
   - The PATTERN of error reveals the ROOT CAUSE

3. **Fix Real Bugs Even If They're Not THE Bug**
   - Canvas sizing was broken (found via logs)
   - World wrapping was broken (found via screenshots)
   - Both needed fixing even though neither was the main issue
   - Each fix improved the system

4. **Performance ≠ Correctness**
   - Throttling doesn't fix coordinate math
   - But it's still good for performance
   - Keep performance fixes separate from correctness fixes

5. **Use Existing Logs Wisely**
   - UILogger output revealed canvas size mismatch
   - No need to add new logging
   - Analyze what you already have first

### Process Lessons

1. **Systematic Elimination Works**
   - Fix one thing at a time
   - Test after each fix
   - User feedback guides next step

2. **Documentation Is Your Friend**
   - Feature_list_2D_Map.txt had the answer
   - Always check docs before deep debugging
   - Document solutions for future reference (this file!)

3. **Integration Issues Are Multi-Layered**
   - Leaflet + Deck.gl integration has many moving parts
   - Coordinate system, scale, canvas size, device pixels, world wrapping
   - Each layer can have issues
   - Fix them in order from most obvious to most subtle

---

## Technical Deep Dive: Why Zoom - 1?

### Leaflet's Zoom System
- Zoom 0 = entire world fits in 256×256 pixels
- Zoom 1 = entire world fits in 512×512 pixels (2× scale)
- Zoom n = entire world fits in 256 × 2^n pixels
- Scale = 2^zoom

### Deck.gl MapView Zoom System
- Designed to match Mapbox GL JS zoom system
- Zoom 0 = same as Leaflet zoom 1 (historical reasons)
- To match Leaflet's scale, Deck.gl needs zoom - 1

### The Coordinate Math
```
Leaflet center: (lng, lat) at zoom z
Leaflet scale: 2^z

To convert Leaflet zoom to Deck.gl zoom:
deckZoom = leafletZoom - 1

To convert screen pixels to world coordinates:
worldX = (screenX - centerX) / scale
worldY = (screenY - centerY) / scale

If scales don't match, worldX and worldY are wrong!
```

### Why It Amplifies At Higher Zoom
At zoom 1, error = 2¹ - 2⁰ = 2 - 1 = 1 pixel/degree
At zoom 5, error = 2⁵ - 2⁴ = 32 - 16 = 16 pixels/degree
At zoom 10, error = 2¹⁰ - 2⁹ = 1024 - 512 = 512 pixels/degree

The error DOUBLES with each zoom level because scale is exponential!

---

## Prevention For Future

### Before Integration
1. Read both libraries' documentation on coordinate systems
2. Check if zoom/scale systems match
3. Test at multiple zoom levels (especially high zoom)
4. Document any required offsets in Feature_list

### During Development
1. Test pan/zoom behavior at zoom 1, 5, 10, 15
2. Check if error increases with zoom (exponential) or stays constant (linear)
3. Verify objects stay locked to known geographic coordinates
4. Use logs to check coordinate transforms

### Code Standards
1. Always comment coordinate system transformations
2. Document zoom offsets with "CRITICAL" comments
3. Include math explanation for non-obvious transforms
4. Reference documentation in comments

---

## Summary

**Root Cause**: Zoom scale mismatch between Leaflet (2^zoom) and Deck.gl MapView (2^(zoom-1))

**Failed Fixes**: Coordinate system declaration, throttling, device pixels (though device pixels WAS a real issue)

**Breakthrough**: User's observation that error "amplified at higher zoom" = exponential error

**Solution**: Pass `zoom - 1` to Deck.gl instead of `zoom`

**Time To Fix**: Multiple iterations over extended debugging session

**Key Insight**: Read the docs! Feature_list_2D_Map.txt documented this requirement.

**Files Modified**:
- app.js:1872 (zoom offset in syncDeckWithLeaflet)
- app.js:1757 (useDevicePixels: false)
- app.js:1738 (MapView with repeat: true)
- app.js:1183, 1217, 1239 (wrapLongitude: true on layers)

**Related Issues Fixed**:
- Canvas size mismatch (auto-correction)
- World wrapping (MapView + wrapLongitude)
- Device pixel ratio (useDevicePixels: false)
- Performance (60 FPS throttling)

---

## Final Thoughts

This was a textbook example of **integration debugging**. The issue wasn't in Leaflet OR Deck.gl individually - both work perfectly. The issue was in the **handoff between them**.

The user's technical intuition was excellent:
- Suggested coordinate system issues early
- Recognized timing wasn't the problem
- Provided precise symptom descriptions
- Noticed the zoom level correlation

The debugging process was systematic but could have been faster by:
1. Reading Feature_list_2D_Map.txt FIRST
2. Testing at extreme zoom levels earlier
3. Calculating expected vs actual scales mathematically

**Most Important Lesson**: When integrating two coordinate systems, verify scales match at multiple zoom levels. Exponential errors hide at low zoom and explode at high zoom.

---

**Status**: ✅ RESOLVED
**Confidence**: 100% - Objects now locked to geographic positions at all zoom levels
**Next Steps**: Monitor for any edge cases, document zoom offset requirement prominently

---

# Lessons Learned: Phase 3 Modularization Bugs
## ES6 Module Integration Issues

**Date**: 2025-11-25
**Context**: Refactoring monolithic app.js into ES6 modules (Phase 3: Data Operations)
**Issues**: Runtime errors after modularization, test failures
**Status**: ✅ RESOLVED

---

## Problem Statement

### Initial Symptoms After Phase 3 Completion
- Application loaded successfully
- Console showed multiple ReferenceErrors
- Ground tracks did not display on map
- 2 out of 85 tests failing
- Validation errors in console logs

### Specific Errors
1. `Uncaught ReferenceError: toggleSatelliteSelection is not defined`
2. `Uncaught ReferenceError: editSatellite is not defined`
3. Ground tracks not rendering (silent failure)
4. Test failures:
   - "Can update satellite" ❌
   - "Cannot mutate state directly (panelExpanded)" ❌

---

## Root Causes & Solutions

### Issue #1: HTML Event Handler Function Visibility

**Problem**: Functions called from HTML onclick/onchange handlers threw ReferenceError

**Code Context**:
```javascript
// app.js (ES6 module)
function editSatellite(satelliteId) { /* ... */ }
function toggleSatelliteSelection(satelliteId) { /* ... */ }

// HTML template (lines 1161, 1164-1165)
<input onchange="toggleSatelliteSelection(${sat.id})">
<td onclick="editSatellite(${sat.id})">${sat.name}</td>
```

**Why It Failed**:
- ES6 modules have their own scope (not automatically global)
- HTML event handlers look for functions in global (`window`) scope
- Functions existed in module scope but were inaccessible to HTML

**Solution** (app.js:2759-2761):
```javascript
// Explicitly export functions to global scope
window.editSatellite = editSatellite;
window.toggleSatelliteSelection = toggleSatelliteSelection;
window.toggleSatelliteWatchlist = toggleSatelliteWatchlist;
```

**Lesson**:
- ES6 module functions are private by default
- Functions called from inline HTML handlers MUST be on `window` object
- Better approach: Use event delegation instead of inline handlers
- Alternative: Programmatically attach event listeners after rendering

**Prevention**:
- Avoid inline onclick/onchange handlers in modular code
- Use data attributes + event delegation pattern
- Document which functions need global exposure

---

### Issue #2: ES6 Module Access to Global Libraries

**Problem**: Ground tracks failed to render (silent failure in propagation.js)

**Code Context**:
```html
<!-- index.html:29 - Library loaded via script tag -->
<script src="https://unpkg.com/satellite.js@5.0.0/dist/satellite.min.js"></script>
```

```javascript
// propagation.js (ES6 module) - WRONG
export function propagateSatellite(tleLine1, tleLine2, date) {
    const satrec = satellite.twoline2satrec(tleLine1, tleLine2);
    // ReferenceError: satellite is not defined (in module scope!)
}
```

**Why It Failed**:
- `satellite.js` creates `window.satellite` global
- ES6 modules don't have automatic access to window globals
- `satellite` identifier wasn't in module scope

**Solution** (propagation.js:52-57):
```javascript
export function propagateSatellite(tleLine1, tleLine2, date) {
    // Explicitly access global library via window
    const satellite = window.satellite;
    if (!satellite) {
        logger.error('satellite.js library not loaded', logger.CATEGORY.SATELLITE);
        return null;
    }

    const satrec = satellite.twoline2satrec(tleLine1, tleLine2);
    // ... rest of function
}
```

**Lesson**:
- ES6 modules are isolated from global scope
- Libraries loaded via `<script>` tags must be accessed as `window.libraryName`
- Always check library exists before use
- Add helpful error messages for missing dependencies

**Prevention**:
- Document external script dependencies in module JSDoc
- Consider using import maps or bundlers for better dependency management
- Test with library intentionally missing to verify error handling

---

### Issue #3: Property Name Mismatch (Satellite Update)

**Problem**: Test "Can update satellite" failed - validation rejected valid updates

**Code Context**:
```javascript
// Satellite objects in state use:
{
    tleLine1: '1 25544U ...',
    tleLine2: '2 25544  51.6416 ...'
}

// Validation function expects:
function validateSatellite(satellite) {
    validateTLE(satellite.tle1, satellite.tle2); // ← Looking for tle1/tle2!
}

// updateSatellite() merged object and passed to validation:
const updatedSatellite = { ...satellite, ...updates };
validate(updatedSatellite); // ← Has tleLine1/tleLine2, needs tle1/tle2!
```

**Why It Failed**:
- Internal storage: `tleLine1`, `tleLine2`
- Validation expects: `tle1`, `tle2`
- Update function merged without converting property names
- Validation failed because it couldn't find `tle1` and `tle2` properties

**Solution** (satelliteState.js:347-352):
```javascript
// Convert property names for validation
const validationData = {
    name: updatedSatellite.name,
    tle1: updatedSatellite.tleLine1,  // Convert: tleLine1 → tle1
    tle2: updatedSatellite.tleLine2   // Convert: tleLine2 → tle2
};

const validation = validateSatellite(validationData);
```

**Lesson**:
- Property names must be explicitly mapped at module boundaries
- Don't assume internal storage matches external API/validation
- Storage layer and validation layer can use different schemas
- Always convert/adapt at the boundary

**Prevention**:
- Document expected property names in JSDoc (`@param {Object} data - {tle1, tle2}`)
- Use TypeScript interfaces to catch mismatches at compile time
- Create adapter/mapper functions for property name conversions
- Write integration tests that exercise full data flow (add → update → retrieve)

---

### Issue #4: Test State Pollution

**Problem**: Test "Cannot mutate state directly (panelExpanded)" failed

**Code Context**:
```javascript
// Previous test left state changed:
uiState.setPanelExpanded(true); // panelExpanded = true

// Immutability test expected initial state (false):
const state1 = uiState.getUIState(); // panelExpanded = true (NOT false!)
state1.panelExpanded = true; // Try to mutate to true
const state2 = uiState.getUIState(); // panelExpanded = true

// Test expected: state2.panelExpanded !== state1.panelExpanded
// Actual: true !== true → FALSE (test fails!)
```

**Why It Failed**:
- Test assumed initial state would be `panelExpanded = false`
- Previous test left `panelExpanded = true`
- Trying to mutate `true → true` made both values equal
- Test failed because values were unexpectedly identical

**Solution** (test-state.html:334):
```javascript
// Reset to predictable initial state before testing
uiState.reset(); // panelExpanded=false, activeSection='time'

const state1 = uiState.getUIState();
state1.panelExpanded = true; // Try to mutate
const state2 = uiState.getUIState();

// Now works: false !== true ✓
```

**Lesson**:
- Tests must be independent of execution order
- Reset to known state before testing assumptions
- Don't rely on state from previous tests
- Immutability tests especially need predictable initial values

**Prevention**:
- Use `beforeEach()` / `afterEach()` test hooks for cleanup
- Explicitly reset shared state at test start
- Document expected initial state in test descriptions
- Consider using fresh instances for each test

---

## Debugging Process

### What Worked Well
1. **Systematic testing** - Tested immediately after Phase 3 completion
2. **User provided clear feedback** - Screenshots, console logs, specific errors
3. **Incremental fixes** - Fixed one issue at a time, tested each
4. **Root cause analysis** - Didn't just patch symptoms, found underlying issues

### What Could Have Been Better
1. **Prevention** - Could have anticipated ES6 module scope issues
2. **Testing** - Should have run tests BEFORE completing phase
3. **Documentation** - Module dependencies not clearly documented

---

## Key Lessons Learned

### Technical

1. **ES6 Modules Are Isolated By Design**
   - No automatic access to global scope
   - Must use `window.globalVar` to access script-loaded libraries
   - Functions aren't global unless explicitly exported to `window`

2. **Property Name Consistency Across Boundaries**
   - Storage layer can use different names than API/validation layer
   - ALWAYS map/convert at boundaries
   - Document expected schemas clearly

3. **Test Independence Is Critical**
   - State pollution causes false positives/negatives
   - Reset to known state before assertions
   - Use test hooks for cleanup

4. **HTML Event Handlers + Modules Don't Mix Well**
   - Inline handlers require global functions
   - Event delegation is better for modular code
   - Programmatic listeners keep functions private

### Process

1. **Test After Every Phase**
   - Don't wait to discover integration issues
   - Catch bugs when context is fresh
   - Easier to debug recent changes

2. **Listen To Error Messages**
   - "ReferenceError" immediately suggests scope issue
   - Error stack traces pinpoint exact location
   - Console errors are your friend

3. **Write Integration Tests**
   - Unit tests alone miss boundary issues
   - Test data flowing between modules
   - Verify property name conversions

4. **Document Module Dependencies**
   - External libraries (satellite.js)
   - Required global exports
   - Property name mappings

---

## Prevention Checklist

### Before Modularizing
- [ ] Identify functions called from HTML
- [ ] List external libraries used
- [ ] Document property name schemas
- [ ] Plan test strategy

### During Modularization
- [ ] Expose HTML handler functions to `window`
- [ ] Access globals via `window.libraryName`
- [ ] Map property names at boundaries
- [ ] Test after each extraction

### After Modularization
- [ ] Run full test suite
- [ ] Check browser console for errors
- [ ] Test all UI interactions
- [ ] Verify external library integration

---

## Summary

**Root Causes**:
1. ES6 module scope isolation (functions not global)
2. Global library access pattern (need `window.satellite`)
3. Property name mismatch (tleLine1 vs tle1)
4. Test state pollution (lack of reset)

**Solutions**:
1. Explicit `window` exports for HTML handlers
2. `window.satellite` access pattern
3. Property name mapping at validation boundary
4. Test state reset before assertions

**Time To Fix**: ~1 hour debugging + fixes

**Key Insight**: ES6 modules provide excellent encapsulation but require explicit handling of:
- Global library access
- HTML event handler exposure
- Data schema mapping at boundaries

**Files Modified**:
- app.js:2759-2761 (global function exports)
- propagation.js:52-57 (window.satellite access)
- satelliteState.js:347-352 (property name mapping)
- test-state.html:334 (test state reset)

**Commits**:
- 0d936b5: Fix Phase 3 runtime errors
- 373e664: Fix 2 failing test cases

**Related Documentation**:
- LESSONS_LEARNED.md (created): General refactoring patterns

---

**Status**: ✅ RESOLVED
**Confidence**: 100% - All tests passing, application functioning correctly
**Next Steps**: Proceed to Phase 4 with these lessons in mind
